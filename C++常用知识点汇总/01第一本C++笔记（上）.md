#### 一. C++基础知识

##### 1. bool类型

​	bool类型的变量可以接受任意类型的表达式或变量（int、double、char*等），其值非0则为true，为0/NULL则为false。

##### 2. 名字空间

（1）名字空间的成员可以是：全局变量、函数、类型和名字空间

（2）作用域限定符 “::”

（3）名字空间指令： using namespace std;

​	该条指令以后的代码，std 中的成员都可见，访问其中的成员都可以省略作用域限定符。

（4）名字空间的声明： using 名字空间名::名字空间成员

​	该语句将名字空间中的特定的成员引入当前作用域，在该作用域中访问这个成员就如同访问自己的成员一样，可以省略作用域限定符。

（5）无名名字空间：不属于任何名字空间的标识符，将会被编译器放到无名名字空间中，使用"::标识符" 访问。

##### 3. sizeof

（1）sizeof 是一个运算符。

（2）sizeof(a=c+d); 运算结果为 a 的存储区大小，括号里的表达式不会被计算，但是提供表达式的类型。例如：double d = 0; cout << sizeof(d+c) << endl; 输出结果为8.

##### 4. 函数调用运算符

func(); 该语句中“()” 叫做函数调用运算符。

##### 5. 大端和小端系统

（1）大端和小端系统都指一种内存对齐方式。

（2）小端系统中，内存低位对应数据低位；大端系统中内存低位对应数据高位。

##### 6. gdb 查找段错误的方法

```
a. gcc -g 088test.c  
b. gdb a.out
c. run
d. bt
e. q y
```

##### 7. 重载

（1）重载与函数的返回值无关，与形参变量名也无关。至于参数的个数、类型和顺序有关。

（2）函数重载的匹配：对于 g++ v4.6.3 编译器匹配优先级的一般原则是：完全匹配 > 常量转换 > 升级转换 > 降级转换 > 省略号匹配 

（3）一个函数指针究竟指向哪个重载版本，有函数指针的类型（包括形参表）决定，而不由调用实参决定。

```c
void(*pfunc)(int, float) = foo;
pfunc(10,20);    //调用 foo(int, float)
```

（4）函数重载原理：C++ 编译器通过对函数进行换名，将参数表信息整合到函数名中，实现函数重载与名字冲突的矛盾。

```
nm xxx.o   //可以查看一个目标文件符号
01overload.cpp 中四个 foo 函数重载换名为：_Z3fooi  _Z3fooif  _Z3fooii  _Z3foov
```

（5）extern "C" 声明的作用：函数声明中加入 extern "C"，要求 C++ 编译器不对函数做换名，便于 C 的程序调用该函数，但是这样的函数无法重载。

##### 8. 缺省参数

（1）如果函数某一个参数带有缺省值，那么这个参数的右侧的所有参数都必须带有缺省值。

（2）如果函数的定义和声明分开，缺省参数应该写在函数的声明部分，定义部分不要写，但可以加个注释，提高代码的可读性。

（3）函数的哑元参数：只有类型二没有变量名的形参成为哑元。

```
例如：void func(int);
作用：a. 为了兼容以前的旧代码（例如：升级优化算法库）
b. 运算符重载（区分前后 ++/--）
```

##### 9. inline 关键字与内联函数

（1）inline 关键字的作用：使用 inline 关键字修饰的函数，表示这个函数是内联函数。编译器将会尝试做内联优化，避免函数调用的开销（跳转）。

（2）内联函数的使用场景

```
a. 多次调用的小二简单的函数适合内联。
b. 调用次数少或者大二复杂的函数不适合内联。
c. 递归函数不能内联。
```

（3）内联优化只是一种建议，而不是强制的要求，能否做内联优化取决于当前编译器的优化策略。即有些函数不加 inline 关键字编译器也会默认处理为内联，反之有些函数及时加了 inline 关键字，编译器也不会做内联优化。

##### 10. new/delete 和 malloc() / free() 区别

```
a. malloc/free 是 C/C++ 语言的标准库函数；new/delete 是 C++ 的运算符。
b. malloc 只分配指定大小的内存，free 也只释放之前申请的内存；new 在分配内存后，还会调用分配对象的构造函数， delete 在释放内存之前调用对象的析构函数。
c. malloc 分配内存时需要指定具体的内存大小；而 new 分配内存时只需要提供数据类型。
```

补充：C++ 中 new 与 delete 必须配套使用，没有 delete 就会出现内存泄漏，p 没有置为空就会出现野指针。

##### 11. 常用运算符优先级

```
()  > []  > .  > ->  > ++/-- 
```

##### 12. 野指针问题

```c++
int* p1 = new int(10);
delete p1; //所谓释放 p1,就是释放p1所指的那块动态内存， 也就是从此别人可以再使用这块内存了。
// p1 = NULL;  //如果p1不置空，将会变成野指针。指向地址不确定，使用很危险。
cout << *p1 << endl;   // 0
int* p2 = new int(10);
*p1 = 20;  //p1为野指针，意外修改了p2的值
cout << "p1:" << p1 << endl; //p1:0x9e1f008
cout << "p2:" << p2 << endl; //p2:0x9e1f008
cout << *p2 << endl; //20
```

##### 13. 引用

（1）引用就是别名。一个引用一旦初始化，就不能修改引用目标。 int a=10; int &b = a;

（2）常引用：定义引用时加上 const 修饰，即为常引用，不能通过常引用修改引用的目标。

```c++
int a = 10;
const int& b = a;
a = 100; //ok
b = 200; //error
//相当于对 a 的使用场景做了限制，即不能通过 b 改变 a 的值。
//也相当于关闭了一条操作（写）该内存空间的方式（不能通过别名 b 操作）
```

（3）普通引用也叫左值引用，只能引用一个左值。常引用也叫万能引用，既能引用左值，也能引用右值。

##### 14. 左值和右值

（1）左值：可以放在赋值运算符左边，可以被修改，可以取地址。具有**内存空间**的属性。

（2）某些表达式的值也是左值。

a. 前 ++/-- 表达式的值是左值

```c++
++number = 3;
cout << number << endl; //3
++++number;     //5
```

b. 赋值表达式的值是左值

```c++
(number = 5) = 7;
cout << number << endl; // 7
```

（3）右值：只能放在赋值运算符的右边，不可被修改，不可取地址。

（4）常见右值

a. 字面值常量

b. 大部分表达式的值 

```c++
a + b = c; //error
(a + b)++; //error
```

c. 后 ++/-- 都是右值

```c++
int res = number++; //先返回，再自加。返回的是一个临时变量，返回给 res 后则丢失，不能再使用该存储区。
number++ = 3; // error
```

d. 函数的返回值

```c++
int foo(void)
{
    int a = 100;
    //函数中return a;语句返回一个临时变量，称为将亡右值，保存函数返回值。
    return a;
}
int mian()
{
    //函数的返回值是个将亡右值，res 得到一个临时变量，该语句结束时临时变量马上释放。
    int res = foo(); 
    foo() = 10; //error
    ++foo(); //error
    int* p = &foo(); //error
}
```

e. 类型转换过程中的临时变量，也是一个右值。

##### 15. 引用作函数形参

（1）引用作函数形参的作用：

```
a. 可以直接修改实参变量的值。
b. 可以减小函数调用的开销（不需要为形参分配内存）。
c. 也可以避免虚实结合过程中对实参值得复制过程。
```

（2）引用参数有可能意外修改实参值，如果不希望修改实参变量本省，仅仅就是为了提高传参效率，可以将形参定义为常引用，提高效率的同时还可以接受常量型的实参。

##### 16. 引用做函数返回值

